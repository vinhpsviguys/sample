using System;
using System.Collections;


namespace CoreLib
{
    public class NewLogic // phan biet tac dung HP tung lan, HP dung ngay va mat (doc lap)
    {
<<<<<<< HEAD
        public const int LIMIT_TURNS = 40;
=======
        public const int LIMIT_TURNS = 10;
>>>>>>> origin/master

        //Character attacker;
        //Character defender;
        //internal CharacterPlayer _attacker;
        //internal CharacterPlayer _defender;
        public NewCharacterStatus attStatus;
        public NewCharacterStatus defStatus;

		ArrayList states = new ArrayList();
		int turns = 0;

		bool turnning = false;
        int secondAttack;

        //public NewLogic(CharacterPlayer _attacker, CharacterPlayer _defender)
        //{
        //    this._attacker = _attacker;
        //    this._defender = _defender;
        //    attStatus = new NewCharacterStatus(_attacker);
        //    defStatus = new NewCharacterStatus(_defender);
        //    secondAttack = _defender.playerId;

        //    turns = LIMIT_TURNS;
        //    //Console.WriteLine("attacker = " + attacker.toJSON().ToString());
        //    //Console.WriteLine("defender = " + defender.toJSON().ToString());
        //    Constants.init();
        //}

        public NewLogic(Character attacker, Character defender)
        {
            //this.attacker = attacker;
            //this.defender = defender;
            attStatus = new NewCharacterStatus(attacker);
            defStatus = new NewCharacterStatus(defender);
            attStatus.setConditionManager(new ConditionManager(attStatus, this));
            defStatus.setConditionManager(new ConditionManager(defStatus, this));
            secondAttack = defender.playerId;

            turns = LIMIT_TURNS;
            //Console.WriteLine("attacker = " + attacker.toJSON().ToString());
            //Console.WriteLine("defender = " + defender.toJSON().ToString());
            Constants.init();
        }



        


		
        public void setFirstID(int firstID)
        {
            this.secondAttack = 3 - firstID;
        }

		//public static NewCharacterStatus createStatus(Character character)
		//{
		//	return new NewCharacterStatus(character);
		//}

		public void beginTurnWithoutLogic(NewCharacterStatus attacker, NewCharacterStatus defender)
		{
			if (turnning) throw new Exception("endTurn must be called before beginTurn.");
			this.attStatus = attacker;
			this.defStatus = defender;
			turnning = true;
		}

		public void endTurnWithoutLogic(NewCharacterStatus attacker, NewCharacterStatus defender)
		{
			if (!turnning) throw new Exception("beginTurn must be called before endTurn.");
			if (attStatus != attacker && defStatus != defender) throw new Exception("Targets of endTurn must be same To beginTurn.");
			turnning = false;
		}

		public BeginTurnResult beginTurn(NewCharacterStatus attacker, NewCharacterStatus defender) // ok
		{
			if (turnning) throw new Exception("endTurn must be called before beginTurn.");
			this.attStatus = attacker;
			this.defStatus = defender;
            this.attStatus.rebuildFormulaOfIndexes(defStatus);
            this.defStatus.rebuildFormulaOfIndexes(attStatus);
			turnning = true;
			// xet cac di trang
			// tun thi bo qua moi thu tru hoi mau
			Console.WriteLine("Player " + attStatus.playerID + " is attacking Player " + defStatus.playerID);


            bool poison = attStatus.effects.ContainsKey(NewEffect.Poisoning);
            bool burn = attStatus.effects.ContainsKey(NewEffect.Burn);
            bool hypnotic = attStatus.effects.ContainsKey(NewEffect.Hypnotic);
            bool stun = attStatus.effects.ContainsKey(NewEffect.Stun);
            bool freezing = attStatus.effects.ContainsKey(NewEffect.Freezing);
            bool bleed = attStatus.effects.ContainsKey(NewEffect.Bleed);
            bool immo = attStatus.effects.ContainsKey(NewEffect.Immobilization);
            bool blind = attStatus.effects.ContainsKey(NewEffect.Blind);
            bool glamour = attStatus.effects.ContainsKey(NewEffect.Glamour);
            BeginTurnResult result = null;

            ArrayList states = new ArrayList();

            if (hypnotic || stun || freezing)
            {
                float recovery = (float)attStatus.getCurrentIndex(Indexes.hp_recor_na);

                float Health = (float)attStatus.getCurrentIndex(Indexes.hp_na);

                float HealthBuff = (float)calculateIndex(attStatus, defStatus, Indexes.hp_buff_na);

                float HealthPassive = (float)calculateIndex(attStatus, defStatus, Indexes.hp_passive_na);

                attStatus.decreaseIndex(Indexes.hp_buff_na);

                float delta = bleed? 0f: HealthBuff + recovery + HealthPassive;

                delta -= burn ? (int)attStatus.effects[NewEffect.Burn].getIndex("burn_damage", 0) : 0;
                delta -= poison ? (int)attStatus.effects[NewEffect.Poisoning].getIndex("poison_damage", 0) : 0;
                //Console.WriteLine("damage Poison "+ (int)attStatus.effects[NewEffect.Poisoning].getIndex("poison_damage", 0));
                //if (bleed) delta -= recovery;

                if (delta > 0)
                {
                    // tinh toan hoi mau
                    if (glamour)
                    {
                        // hoi mau nguoc
                        delta = -delta;
                    }
                    
                }

                //Console.WriteLine("BeginTurn delta Health = " + delta);

                if (delta != 0)
                {
					State state = new State(attStatus.playerID, attStatus.playerID);
                    state.setIdSkill(0);

                    //state.healthAtt = Health + delta;
                    //state.healthDef = (float)defStatus.getCurrentIndex(Indexes.hp_na);

                    float hp_fix = attStatus.setHP(Health + delta);
                    //attStatus.setHP(hp_fix);
                    //attStatus.setIndex(attStatus.midIndexes, Indexes.hp_na, hp_fix);
                    //attStatus.setIndex(attStatus.curIndexes, Indexes.hp_na, hp_fix);
                    state.setHP(attStatus, defStatus);

					NewEffect effect = new NewEffect(attStatus.playerID, "HealthChanges", "", -1, 0);
					effect.playerID = attStatus.playerID;
					state.setEffects(new ArrayList() { effect });
                    if (hp_fix != Health)
					    states.Add(state);

					
                }
				result = new BeginTurnResult(attacker.playerID, false);
				result.states = states;


                return result;
            }
            else
            {
                if (immo || blind)
                {
                    if (immo && attacker.character.characteristic.Type == Characteristic.CharacterType.MELE)
                    {
                        // khoa skill active
                    }

                    if (blind && attacker.character.characteristic.Type == Characteristic.CharacterType.RANGER)
                    {
                        // khoa skill active
                    }
                }

                float recovery = (float)attStatus.getCurrentIndex(Indexes.hp_recor_na);

                float Health = (float)attStatus.getCurrentIndex(Indexes.hp_na);

                float HealthBuff = (float)calculateIndex(attStatus, defStatus, Indexes.hp_buff_na);

                float HealthPassive = (float)calculateIndex(attStatus, defStatus, Indexes.hp_passive_na);

                attStatus.decreaseIndex(Indexes.hp_buff_na);

                float delta = bleed? 0f: HealthBuff + HealthPassive + recovery;

                delta -= burn ? (int)attStatus.effects[NewEffect.Burn].getIndex("burn_damage", 0) : 0;
                delta -= poison ? (int)attStatus.effects[NewEffect.Poisoning].getIndex("poison_damage", 0) : 0;
                //Console.WriteLine("damage Poison " + (poison ? (int)attStatus.effects[NewEffect.Poisoning].getIndex("poison_damage", 0) : 0));
                //if (bleed) delta -= recovery;

                // tinh toan hoi mau
                if (glamour)
                {
                    // hoi mau nguoc
                    if (delta > 0)
                        delta = -delta;
                }


                //Console.WriteLine("BeginTurn delta Health = " + delta);

                if (delta != 0)
                {
					State state = new State(attStatus.playerID, attStatus.playerID);
                    state.setIdSkill(0);
					//state.healthAtt = Health + delta;
					//state.healthDef = (float)defStatus.getCurrentIndex(Indexes.hp_na);
                    float hp_fix = attStatus.setHP(Health + delta);
                    //attStatus.setIndex(attStatus.midIndexes, Indexes.hp_na, hp_fix);
                    //attStatus.setIndex(attStatus.curIndexes, Indexes.hp_na, Health + delta);

                    state.setHP(attStatus, defStatus);

					NewEffect effect = new NewEffect(attStatus.playerID, "HealthChanges", "", -1, 0);
					effect.playerID = attStatus.playerID;
					//ArrayList effects = new ArrayList();
					//effects.Add(effect);
					state.setEffects(new ArrayList() { effect });
                    if (hp_fix != Health)
					states.Add(state);
                }


            }
			result = new BeginTurnResult(attacker.playerID, true);
			result.states = states;
			return result;
		}


        private MyDictionary<string, string> checkAbnormalStatusHappen(ArrayList saveEffects) {
            MyDictionary<string, string> happenedStatus = new MyDictionary<string, string>();
            foreach (string status in attStatus.character.abDic.Keys)
            {// luu y danh gia
                if (isHappend(status))
                {

                    Console.WriteLine("Generate abnoraml Status "+ status);
                    NewEffect effect = attStatus.character.abDic[status].affect(attStatus, defStatus);
                    //Console.WriteLine(status + " effect with def Count" + defStatus.atomics.Keys.Count);
                    effect.duration = (int)calculateIndex(attStatus, defStatus, attStatus.character.abDic[status].getName() + "_duration");
                    switch (effect.name)
                    {


                        case NewEffect.Freezing:
                            effect.duration -= (int)Math.Max(0, calculateIndex(defStatus, attStatus, Indexes.frz_dure_na));
                            break;
                        case NewEffect.Poisoning:
                            //isPoisoning = true;
                            effect.duration -= (int)Math.Max(0, calculateIndex(defStatus, attStatus, Indexes.pOi_dure_na));
                            break;
                        case NewEffect.Shock:

                            effect.duration -= (int)Math.Max(0, calculateIndex(defStatus, attStatus, Indexes.eLe_dure_na));
                            break;
                        case NewEffect.Burn:
                            //isBurn = true;
                            effect.duration -= (int)Math.Max(0, calculateIndex(defStatus, attStatus, Indexes.bur_dure_na));
                            break;
                    }
                    if (effect.duration > 0) {
                        saveEffects.Add(effect);
                        happenedStatus.Add(effect.name, effect.name);
                    } else {
                        // loai bo ngay do duration = 0;
                        if (effect.playerID == attStatus.playerID) {
                            attStatus.removeEffect(effect.name);

                        } else if (effect.playerID == defStatus.playerID) {
                            defStatus.removeEffect(effect.name);
                        } else if (effect.playerID == 3) {
                            attStatus.removeEffect(effect.name);
                            defStatus.removeEffect(effect.name);
                        }

                    }


                }
            }

            // tinh lai cac chi so va cong thuc
            if (happenedStatus.Keys.Count > 0) {
                Console.WriteLine("Recompute All Indexes Due to New Abnormal Status Happening");
                attStatus.recomputeIndexesBeforeActive(defStatus);
                defStatus.recomputeIndexesBeforeActive(attStatus);
            }

            return happenedStatus;
        }

        private void oneAttack(ArrayList savedEffects, int idSkill, ArrayList states) {
            Random random = new Random();
            MyDictionary<string, string> occuredAbs = checkAbnormalStatusHappen(savedEffects);
            bool isBurn = occuredAbs.ContainsKey(NewEffect.Burn);
            bool isPoisoning = occuredAbs.ContainsKey(NewEffect.Poisoning);
            bool bleed = attStatus.effects.ContainsKey(NewEffect.Bleed);
            bool glamour = attStatus.haveAbnomarlStatusByName(NewEffect.Glamour);
            bool sleep = defStatus.haveAbnomarlStatusByName(NewEffect.Sleep);


            ArrayList damages = attStatus.damageWith(defStatus);
            bool isCritical = (bool)damages[3];
            bool isDodge = random.NextDouble() < (float)defStatus.calculateIndex(attStatus, Indexes.dOdGe_cha_na);
            bool isBlock = random.NextDouble() < (float)defStatus.calculateIndex(attStatus, Indexes.block_cha_na);

            float d1 = isBlock ? 0 : (float)damages[0];
            float d2 = isDodge ? 0 : (float)damages[1];
            float d3 = (float)damages[2];

            //Debug.Log("ToTal Damage = " + attStatus.getCurrentIndex("total_damage"));

            float total_damage = calculateIndex(attStatus, defStatus, "total_damage");

            isDodge = sleep ? false : isDodge;
            isBlock = sleep ? false : isBlock;

            //Debug.Log("ToTal Damage = "+total_damage);

            //Console.WriteLine("burn =  "+isBurn+ " poison = "+isPoisoning);

            if (isBurn)
            {
                NewEffect effect = defStatus.effects[NewEffect.Burn];
                int damage = (int)Math.Round(calculateIndex(attStatus, defStatus, "burn_damage"));
                effect.setIndex("burn_damage", damage);
            }

            if (isPoisoning)
            {
                NewEffect effect = defStatus.effects[NewEffect.Poisoning];
                int damage = (int)Math.Round(calculateIndex(attStatus, defStatus, "poison_damage"));
                effect.setIndex("poison_damage", damage);
            }


            if (isBlock)
            {
                NewEffect effect = new NewEffect(defStatus.playerID, "Blocking", "", -1, 0);
                effect.playerID = defStatus.playerID;
                savedEffects.Add(effect);
                total_damage -= d1;
                d1 = 0;
            }
            else
            {
                if (isCritical)
                {
                    NewEffect effect = new NewEffect(attStatus.playerID, "Critical", "", -1, 0);
                    effect.playerID = defStatus.playerID;
                    savedEffects.Add(effect);
                    attStatus.disableCondition(ConditionManager.Critical);
                }
            }

            if (isDodge)
            {
                total_damage -= d2;
                d2 = 0;
                NewEffect effect = new NewEffect(defStatus.playerID, "Dodge", "", -1, 0);
                effect.playerID = defStatus.playerID;
                savedEffects.Add(effect);
            }

            int d = Math.Max((int)Math.Round(total_damage), 1);
            State state = new State(attStatus.playerID, defStatus.playerID);
            state.setIdSkill(idSkill);
            //Console.WriteLine("Finish Check HP " + (float)attStatus.getCurrentIndex(Indexes.hp_na) + " " + ((float)defStatus.getCurrentIndex(Indexes.hp_na)) + " " + attStatus.playerID + " " + defStatus.playerID);

            float hp_active = calculateIndex(attStatus, defStatus, Indexes.hp_active_na);

            hp_active = glamour ? hp_active > 0 ? -hp_active : hp_active : hp_active;

            hp_active = bleed ? hp_active > 0 ? 0f : hp_active : hp_active;

            // trong skill active co chua hoi mau
            attStatus.decreaseIndex(Indexes.hp_active_na);
            attStatus.rebuildFomulaOfIndex(Indexes.hp_active_na);
            // chi dung 1 lan nen loai bo va tinh toan ngay


            float healthAtt = Math.Max(0, (float)attStatus.getCurrentIndex(Indexes.hp_na) + hp_active);
            float healthDef = Math.Max(0, (float)defStatus.getCurrentIndex(Indexes.hp_na) - d);

            healthAtt = attStatus.setHP(healthAtt);
            healthDef = defStatus.setHP(healthDef);
            state.setHP(attStatus, defStatus);
            //Console.WriteLine("Finish Damage " + healthAtt + " " + healthDef + " " + attStatus.playerID + " " + defStatus.playerID);
            // tinh lai cac chi so Abrnomalstatus
            state.damage = d;
            state.setEffects(savedEffects);
            states.Add(state);
            // 1 lan danh thuong
            if (isEndOfCombat()) return;

            bool isReturn = random.NextDouble() < (float)defStatus.getCurrentIndex(Indexes.return_chance);
            bool isReturnPhysical = random.NextDouble() < (float)defStatus.getCurrentIndex(Indexes.physical_return_chance);
            bool isReturnMagical = random.NextDouble() < (float)defStatus.getCurrentIndex(Indexes.magical_return_chance);
            float returnDamage = 0;
            if (isReturn)
            {
                returnDamage += d1 * ((float)attStatus.getCurrentIndex(Indexes.physical_return_ratio) + (float)attStatus.getCurrentIndex(Indexes.return_ratio));
                returnDamage += d2 * ((float)attStatus.getCurrentIndex(Indexes.magical_return_ratio) + (float)attStatus.getCurrentIndex(Indexes.return_ratio));
                returnDamage += d3 * (float)attStatus.getCurrentIndex(Indexes.return_ratio);
            }
            else
            {
                if (isReturnMagical)
                {
                    returnDamage += d2 * (float)attStatus.getCurrentIndex(Indexes.magical_return_ratio);
                }

                if (isReturnPhysical)
                {
                    returnDamage += d1 * (float)attStatus.getCurrentIndex(Indexes.physical_return_ratio);
                }
            }

            returnDamage = (int)Math.Round(returnDamage);

            if (returnDamage > 0)
            {
                state = new State(defStatus.playerID, attStatus.playerID);
                state.setIdSkill(0);
                state.damage = d;
                healthAtt = (float)defStatus.getCurrentIndex(Indexes.hp_na);
                healthDef = Math.Max(0, (float)attStatus.getCurrentIndex(Indexes.hp_na) - returnDamage);
                attStatus.setHP(healthDef);
                state.setHP(attStatus, defStatus);

                ArrayList effs = new ArrayList();
                NewEffect effect = new NewEffect(defStatus.playerID, "ReturnDamage", "", 0, 0);
                effect.playerID = attStatus.playerID;
                effs.Add(effect);
                state.setEffects(effs);
                states.Add(state);
                if (isEndOfCombat()) return;
            }
        }

        public ArrayList activeBranch(ArrayList effects, int idSkill)
        {
            Console.WriteLine("++++++++++++++++++++activeBranch{0,3}+++++++++++++++++++",idSkill);

            attStatus.setIndex(attStatus.midIndexes, Indexes.hp_active_na, 0f);
            attStatus.setIndex(attStatus.midIndexes, Indexes.total_damage_na, 0f);
            attStatus.setIndex(attStatus.midIndexes, Indexes.pure_da_na, 0f);
            // total_damage reset
            System.Random random = new System.Random();
            ArrayList states = new ArrayList();
            int successive_attacks = (int)calculateIndex(attStatus,defStatus, Indexes.successive_attacks);
            // kiem tra xem co effects lien quan den trong skill nay khong passive + buff
            successive_attacks = Math.Max(1, successive_attacks);
            attStatus.conManager.enableCondition("when_hit");
            // tong hop cong thuc
            // them vao cac bien so khong co trong cac cong thuc
            attStatus.preProcessBeforeDamaging(defStatus);
            defStatus.preProcessBeforeDamaging(attStatus);

            for (int i = 0; i < successive_attacks; i++) {
                
                // tinh den su xuat hien cua cac abnomarl
                // tinh lai cac chi so
                // tinh damage
                // xet dodege
                // xet block
                //sinh state // neu dau tien thi kem cac effect va cac abrnomaml
                // xet co bi phan damage khong sinh phan damage
                // need Code hits
                // enable shield block in 1 round
                ArrayList effs = new ArrayList();

                float hits  = (float)attStatus.getMidIndex(Indexes.hits_na);
                attStatus.setIndex(attStatus.midIndexes, Indexes.hits_na, hits + 1);
                attStatus.setIndex(attStatus.midIndexes, Indexes.successful_hits_na, hits + 1);
                if (i == 0) {
                    effs.AddRange(effects);
                }
                oneAttack(effs, idSkill, states);
                if (isEndOfCombat()) break;


                bool isMulticast = random.NextDouble() < (float)attStatus.calculateIndex(defStatus, Indexes.mul_ca_cha_na);
                if (isMulticast && i == successive_attacks - 1)
                {// them 1 lan danh nua nhung chi co hieu ung Multicast
                    oneAttack(new ArrayList(), idSkill, states);
                    if (isEndOfCombat()) break;
                }


                // tinh dmage


            }

            attStatus.conManager.disableCondition("when_hit");
            attStatus.setIndex(attStatus.midIndexes, Indexes.hits_na, 0f);
            attStatus.setIndex(attStatus.midIndexes, Indexes.successful_hits_na, 0f);

            return states;
        }



        public bool isHappend(string status) {
            float chance = 0;
            NewEffect effect = null;
            switch (attStatus.character.abDic[status].getName()) {

				case NewEffect.Impotent:
                    chance = Math.Max(0, calculateIndex(attStatus, defStatus, Indexes.imp_cha_na) 
                        - calculateIndex(defStatus,attStatus, Indexes.imp_res_na));
                    break;
        		case NewEffect.Hypnotic:
                    chance = Math.Max(0, calculateIndex(attStatus, defStatus, Indexes.hyp_cha_na) 
                        - calculateIndex(defStatus, attStatus, Indexes.hYp_res_na));
                    break;
        		case NewEffect.Rot:
                    chance = Math.Max(0, calculateIndex(attStatus, defStatus, Indexes.rot_cha_na) 
                        - calculateIndex(defStatus, attStatus, Indexes.rOt_res_na));
                    break;
        		case NewEffect.Pain:
                    chance = Math.Max(0, calculateIndex(attStatus, defStatus, Indexes.pain_cha_na) 
                        - calculateIndex(defStatus, attStatus, Indexes.pain_res_na));
                    break;
        		case NewEffect.Bleed:
                    chance = Math.Max(0, calculateIndex(attStatus, defStatus, Indexes.bleed_cha_na) 
                        - calculateIndex(defStatus, attStatus, Indexes.bLeed_res_na));
                    break;
        		case NewEffect.Crazy:
                    chance = Math.Max(0, calculateIndex(attStatus, defStatus, Indexes.crazy_cha_na) 
                        - calculateIndex(defStatus,attStatus, Indexes.craZY_res_na));
                    break;
        		case NewEffect.Dull:
                    chance = Math.Max(0, calculateIndex(attStatus, defStatus, Indexes.dull_cha_na) 
                        - calculateIndex(defStatus, attStatus, Indexes.dull_res_na));
                    break;
        		case NewEffect.Stun:
                    chance = Math.Max(0, calculateIndex(attStatus, defStatus, Indexes.stun_cha_na) 
                        - calculateIndex(defStatus, attStatus, Indexes.stun_res_na));
                    break;
        		case NewEffect.Frostbite:
                    chance = Math.Max(0, calculateIndex(attStatus, defStatus, Indexes.fro_cha_na) 
                        - calculateIndex(defStatus, attStatus, Indexes.fro_res_na));
                    break;
        		case NewEffect.Burn:
                    chance = Math.Max(0, calculateIndex(attStatus, defStatus, Indexes.bur_cha_na));
                    break;
        		case NewEffect.Shock:
                    chance = Math.Max(0, calculateIndex(attStatus, defStatus, Indexes.eLe_cha_na));
                    break;
        		case NewEffect.Poisoning:
                    chance = Math.Max(0, calculateIndex(attStatus, defStatus, Indexes.poi_cha_na));
                    break;
        		case NewEffect.Knockback:
                    chance = Math.Max(0, calculateIndex(attStatus, defStatus, Indexes.kno_cha_na) 
                        - calculateIndex(defStatus, attStatus, Indexes.kno_res_na));
                    break;
        		case NewEffect.Immobilization:
                    chance = Math.Max(0, calculateIndex(attStatus, defStatus, Indexes.imm_cha_na) 
                        - calculateIndex(defStatus, attStatus, Indexes.imm_res_na));
                    break;
        		case NewEffect.Blind:
                    chance = Math.Max(0, calculateIndex(attStatus, defStatus, Indexes.blind_cha_na) 
                        - calculateIndex(defStatus, attStatus, Indexes.blind_res_na));
                    break;
        		case NewEffect.Freezing:
                    chance = Math.Max(0, calculateIndex(attStatus, defStatus, Indexes.frz_cha_na));
                    break;
        		case NewEffect.Glamour:
                    chance = Math.Max(0, calculateIndex(attStatus, defStatus, Indexes.gla_cha_na) 
                        - calculateIndex(defStatus, attStatus, Indexes.gla_res_na));
                    break;
        		case NewEffect.Fear:
                    chance = Math.Max(0, calculateIndex(attStatus, defStatus, Indexes.fear_cha_na) 
                        - calculateIndex(defStatus, attStatus, Indexes.fear_res_na));
                    break;
        		case NewEffect.Disease:
                    chance = Math.Max(0, calculateIndex(attStatus, defStatus, Indexes.dis_cha_na) 
                        - calculateIndex(defStatus, attStatus, Indexes.dis_res_na));
                    break;
        		case NewEffect.Sleep:
                    chance = Math.Max(0, calculateIndex(attStatus, defStatus, Indexes.sleep_cha_na) 
                        - calculateIndex(defStatus, attStatus, Indexes.sleep_res_na));
                    break;
                              
            }
            System.Random random = new System.Random();
            float p = (float)random.NextDouble();

            //Console.WriteLine("chance "+ attStatus.character.abDic[status].getName() + " "+chance+" p = "+p);

            return p < chance;
        }


        public void addPassiveSkills(ArrayList skills, NewCharacterStatus target)
        {
            
            NewCharacterStatus vs = getStatusByPlayerID(3 - target.playerID);
            foreach (int idSkill in skills)
            {
                NewSkill skill = target.character.newSkillDic.ContainsKey("Skill" + idSkill) ? target.character.newSkillDic["Skill" + idSkill] : null;
                ArrayList effects = skill.affect(target, vs);

                foreach (NewEffect effect in effects)
                {
                    foreach (AtomicEffect atomic in effect.atomicEffects)
                    {
                        if (atomic.enemy)
                        {// tac dung vao def
                            vs.rebuildFomulaOfIndex(atomic.index);
                        }
                        else
                        {// tac dung vao att
                            target.rebuildFomulaOfIndex(atomic.index);
                        }
                    }
                }

            }
        }


        public ArrayList buffBranch(ArrayList effects, int idSkill) // almost done
        {
            Console.WriteLine("++++++++++++++++++++buffBranch{0,3}+++++++++++++++++++", idSkill);
            ArrayList states = new ArrayList();
            // neu trong so nhung effect cua skill co HP hoac lech thi dung ngay
            State state = null;
            state = new State(attStatus.playerID, defStatus.playerID);
            state.setIdSkill(idSkill);

            float delta_Att = 0;
            float delta_Def = 0;

            attStatus.recomputeIndexesBeforeActive(defStatus);// khong dung

            defStatus.recomputeIndexesBeforeActive(attStatus);// khong dung

            bool attHpBuff = false;
            bool defHpBuff = false;

            foreach (NewEffect effect in effects)
            {
                ArrayList atomics = effect.atomicEffects;

                foreach (AtomicEffect atomic in atomics)
                {
                    if (atomic.index == Indexes.hp_buff_na)
                    {// skill tac dung den health
                        // cong ngay cho me lan nay
                        if (atomic.enemy) defHpBuff = true;
                        else attHpBuff = true;
                        //atomic.decDuration();
                    }

                    if (atomic.enemy) defStatus.rebuildFomulaOfIndex(atomic.index);
                    else attStatus.rebuildFomulaOfIndex(atomic.index);
                }
            }
            if (attHpBuff) {
                delta_Att = calculateIndex(attStatus, defStatus, Indexes.hp_buff_na);
                attStatus.decreaseIndex(Indexes.hp_buff_na);
            }
            else {
                delta_Def = calculateIndex(defStatus, attStatus, Indexes.hp_buff_na);
                defStatus.decreaseIndex(Indexes.hp_buff_na);
            }



            bool bleed = attStatus.effects.ContainsKey(NewEffect.Bleed);
            bool glamour = attStatus.effects.ContainsKey(NewEffect.Glamour);
            //float result = 0;

            float hp_Att = (float)attStatus.getCurrentIndex(Indexes.hp_na);
            float hp_Def = (float)defStatus.getCurrentIndex(Indexes.hp_na);

            if (!bleed && delta_Att > 0) {
                if (glamour) hp_Att -= delta_Att;
                else hp_Att += delta_Att;
            } else {
                if ((bleed && delta_Att < 0) || (!bleed))
                hp_Att += delta_Att;
            }
            hp_Def += delta_Def;
            // Update HP 2 ben o day
            //Console.WriteLine("buff " + hp_Att + " " + hp_Def+" "+delta_Att+" "+delta_Def);
            attStatus.setHP(hp_Att);
            defStatus.setHP(hp_Def);
            state.setHP(attStatus, defStatus);
			if (state != null)
			{
			    state.setEffects(effects);
				states.Add(state);
			}
            return states;
        }

		public ArrayList inTurn(ArrayList actionHandles)
		{
            //Debug.Log("1");
            attStatus.loadDynamicIndexToMid(defStatus);
           // Debug.Log("2");
            defStatus.loadDynamicIndexToMid(attStatus);
           // Debug.Log("3");
            //foreach (string index in attStatus.midIndexes.Keys)
            //{
            //    Debug.Log(index + " = " + attStatus.midIndexes[index]);
            //}
            //Debug.Log("4");


            states.Clear();
           // Debug.Log("5");
            System.Random random = new System.Random();
            //foreach (String index in attStatus.deltaFormulas.Keys)
            //{
            //    Debug.Log("|" + index + "|" + attStatus.deltaFormulas[index]);
            //}

            bool isActive = false;
            foreach (ActionHandle action in actionHandles)
			{
				//action.idSkill = 14;

                Console.WriteLine("++++++++++++++++++++++++++NEWSKILL+++++++++++++++++");

                NewSkill skill = attStatus.character.newSkillDic.ContainsKey("Skill" + action.idSkill) ? attStatus.character.newSkillDic["Skill" + action.idSkill] : null;
				ArrayList effects = new ArrayList();
                // null logic
                //Debug.Log("use skill "+ skill.data.ToString());
                
                effects = skill.affect(attStatus, defStatus);
                foreach (NewEffect effect in effects) {
                    foreach (AtomicEffect atomic in effect.atomicEffects) {
                        if (atomic.enemy) {// tac dung vao def
                            defStatus.rebuildFomulaOfIndex(atomic.index);
                        } else {// tac dung vao att
                            attStatus.rebuildFomulaOfIndex(atomic.index);
                        }
                    }
                }

                //Debug.Log("effect skill " + effects.Count);

                ArrayList subStates = null;

                if (skill.getType() == SkillType.Active) {
                    subStates = activeBranch(effects, action.idSkill);
                    isActive = true;
                    foreach (NewEffect effect in effects)
                    {
                        effect.decDurationOfAtomics();
                        foreach (AtomicEffect atomic in effect.atomicEffects)
                        {
                            if (atomic.enemy)
                            {// tac dung vao def
                                defStatus.rebuildFomulaOfIndex(atomic.index);
                            }
                            else
                            {// tac dung vao att
                                attStatus.rebuildFomulaOfIndex(atomic.index);
                            }
                        }
                    }


					
                } else {
                    subStates = buffBranch(effects, action.idSkill);
                }
                //Debug.Log(subStates + " = " + subStates.Count);
                if (subStates != null)
                states.AddRange(subStates);
                //foreach (State state in subStates)
                //{
                //    states.Add(state);
                //}

                if (isEndOfCombat()) break;
			}



            if (!isActive && attStatus.canAttack())
            {
                if (isEndOfCombat()) return states;
                Console.WriteLine("++++++++++++++++++++++++++NormalAttack+++++++++++++++++");
                ArrayList subStates = activeBranch(new ArrayList(), 0);
                foreach (State state in subStates)
                {
                    states.Add(state);
                }
            }



            return states;
		}

		public EndTurnResult endTurn(NewCharacterStatus attacker, NewCharacterStatus defender) //-1 0 1 2
		{
			if (!turnning) throw new Exception("beginTurn must be called before endTurn.");
			if (attStatus != attacker && defStatus != defender) throw new Exception("Targets of endTurn must be same To beginTurn.");

			turnning = false;
			// loai bo cac effect het han


			//Dictionary<string, ArrayList> effects = attacker.effects; // tai sao trong effects tac dong vao nhan vat lai co effect tac dong vao doi phuong
			ArrayList releasedState = new ArrayList();

            // loai bo effect
            
            foreach (String name in attStatus.effects.Keys)
            {
                NewEffect effect = attStatus.effects[name];
                effect.duration = effect.duration > 0 ? effect.duration - 1 : effect.duration;
                if (effect.duration == 0) {
                    
                    // loai bo o atomic

                    foreach (AtomicEffect atomic in effect.atomicEffects)
                    {
                        if (!attStatus.atomics.ContainsKey(atomic.index)) continue;
                        ArrayList atomicLine = attStatus.atomics[atomic.index];
                        atomicLine.Remove(atomic);

                        if (atomic.condition != "")
                        {
                            ArrayList enableLine = attStatus.enableAtomics[atomic.condition];
                            enableLine.Remove(atomic);
                        }
                    }

                    if (effect.condition != "")
                    {
                        if (attStatus.enableSkills.ContainsKey(effect.condition)) {
                            ArrayList enableLine = attStatus.enableSkills[effect.condition];
                            enableLine.Remove(effect);
                        }
                        
                    }
                    // loai bo o enableAtomics
                    // loai bo o enableSkills

                    // loai bo chinh effect
                    releasedState.Add(effect);
                }
            }

            foreach (NewEffect effect in releasedState)
            {
                attStatus.effects.Remove(effect.name);
            }

            foreach (String name in defStatus.effects.Keys)
            {
                NewEffect effect = defStatus.effects[name];
                if (effect.playerID < 3)
                    effect.duration = effect.duration > 0 ? effect.duration - 1 : effect.duration;
               
                if (effect.duration == 0)
                {

                    // loai bo o atomic

                    foreach (AtomicEffect atomic in effect.atomicEffects)
                    {
                        if (!defStatus.atomics.ContainsKey(atomic.index)) continue;
                        ArrayList atomicLine = defStatus.atomics[atomic.index];
                        atomicLine.Remove(atomic);

                        if (atomic.condition != "")
                        {
                            ArrayList enableLine = defStatus.enableAtomics[atomic.condition];
                            enableLine.Remove(atomic);
                        }
                    }

                    if (effect.condition != "")
                    {
                        if (defStatus.enableSkills.ContainsKey(effect.condition))
                        {
                            ArrayList enableLine = defStatus.enableSkills[effect.condition];
                            enableLine.Remove(effect);
                        }
                        
                    }
                    // loai bo o enableAtomics
                    // loai bo o enableSkills

                    // loai bo chinh effect
                    if (effect.playerID < 3)
                    releasedState.Add(effect);
                }

            }

            foreach (NewEffect effect in releasedState)
            {
                if (effect.playerID == defStatus.playerID || effect.playerID == 3)
                    defStatus.effects.Remove(effect.name);
            }
            this.turns--;
            float Health_1 = (float)attStatus.getCurrentIndex(Indexes.hp_na);
            float Health_2 = (float)defStatus.getCurrentIndex(Indexes.hp_na);
            //Debug.Log("EndTurn " + Health_1 + " " + Health_2);
            return new EndTurnResult((Health_1 <= 0 ? defStatus.playerID : (Health_2 <= 0 ? attStatus.playerID : (turns == 0 ? secondAttack: -1))), releasedState);

		}

        public bool isEndOfCombat() {
            float Health_1 = (float)attStatus.getCurrentIndex(Indexes.hp_na);
            float Health_2 = (float)defStatus.getCurrentIndex(Indexes.hp_na);
            return Health_1 <= 0 || Health_2 <= 0;
        }

		public ArrayList getCurrentStates()
		{
			return states;
		}

        public void fixTurn(int turn)
        {
            if (attStatus.playerID != turn)
            {
                NewCharacterStatus temp = attStatus;
                attStatus = defStatus;
                defStatus = temp;
            }
        }

		public NewCharacterStatus getStatusByPlayerID(int id)
		{
			//Console.WriteLine(attStatus.playerID + " " + defStatus.playerID);
			return (attStatus != null && attStatus.playerID == id) ? attStatus : (defStatus != null && defStatus.playerID == id ? defStatus : null);
		}

        public NewCharacterStatus getStatusByTurn()
        {
            //Console.WriteLine(attStatus.playerID + " " + defStatus.playerID);
            return attStatus;
        }

        public int getRemainingTurns() {
            return turns;
        }

        private float calculateIndex(NewCharacterStatus att, NewCharacterStatus def, string index) {
            string fomulas = index + (att.deltaFormulas.ContainsKey(index) && att.deltaFormulas[index] != "" ? " + "+ att.deltaFormulas[index] : "");
            //Console.WriteLine("calculateIndex " + index + " formulas = " + fomulas); // de log Ishappen Stun
            try {
                float digit = Convert.ToSingle(fomulas);
                Console.WriteLine("calculateIndex index " + index +" fomulas = "+fomulas  + " value = " + digit);
                return digit;
            } catch {
                // khong phai la digit
                return calculateExpression(att, def, fomulas);
            }

            return 0;
        }

		private float calculateExpression(NewCharacterStatus att, NewCharacterStatus def, string fomulas)
		{
			try
			{
				float digit = Convert.ToSingle(fomulas);
                Console.WriteLine("calculateExpression " + " formulas = " + fomulas + " value = " + digit);
				return digit;
			}
			catch
			{
                // khong phai la digit
                float digit = att.calcuateExpression(fomulas, def);
                Console.WriteLine("calculateExpression " +" formulas = " + fomulas+" value = "+digit);
                return digit;
			}

			return 0;
		}
    }
}
